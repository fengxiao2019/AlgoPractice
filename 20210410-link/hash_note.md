保证表的大小是素数
解决冲突的方法：
   分离链接法 - 将散列到同一个值的所有元素保留到一个表中。
        缺点： 需要指针，由于给新的单元分配地址需要时间，导致算法的速度有些减慢，同时算法还要求对另一种数据结构的实现。
        装载因子 load factor 约等于 1
        
   开放寻址法 - open addressing hashing. 
        如果有冲突发生，就重试选择另外的单元，直到找出空的单元为止。hi(x) = (Hash(x) + F(i)) mod tablesize，函数F为解决冲突的方法。
        装填因子 低于0.5 
        方法1  - 线性探测法 
            F(i) = i 相当于逐个探测每个单元（必要时可以绕回）以查找出一个空单元。
            从下面的表格可以看出，当装填因子大于0.5，线性探测法就不是一个好的方法
            缺点：当装填因子大于0.5时，探测次数会随着装填因子的增大而急剧上升，会有严重的一次聚集问题
        
          
            装填因子    插入探测次数 
            
            0.5           2.5
            0.75          8.5
            0.9           50     
   >
   平方探测法: 目的是为了消除线性探测法中的一次聚集问题的冲突解决办法。
   F(i) = i^2
   一旦表被填满超过一半，当表的大小不是素数的时候甚至在表被填满一半之前，就不能保证一次找到一个空单元了。
   这是因为最多有表表的一半可以用作解决冲突的备选位置。
   如果表有一半是空的，并且表的大小是素数，那么我们保证总能够插入一个新的元素。
   缺点：虽然排除了一次聚集，但是散列到同一位置上那些元素将探测相同的备选单元。这叫做二次聚集。
   
   双散列（double hashing）：F(i) = i * hash(X) i = 1 2 3 4 
   hash2(X) = R - (X mod R) R是小于TableSize的素数，eg R = 7
   hash2(49) = 7 - (49 mod 7) = 7 - 0 = 75
   
   再散列：当表达到某一个装填因子时，进行再散列。一般为比2N大的一个素数。
   问题：
    什么是素数？如果一个数如果只能被 1 和它本身整除，那么这个数就是素数
    如何寻找大于某个数的素数？如何判断一个数是否是素数？如何寻找某个范围内的素数？
   python dict 使用哪种方法处理冲突问题的？装填因子是多少？rehash的动作是怎样的？
   redis 使用哪种方法处理冲突问题的？装填因子是多少？rehash的动作是怎样的？
   python 提供了集中dict？实现原理是什么？
   hash 的优点  - 缺点 
   
  如何实现一个hash
  优点：
  与其他表数据结构相比，哈希表的主要优势在于速度。当条目数较多时，这种优势更为明显。当可以预测最大条目数时，哈希表的效率特别高，这样桶数组就可以用最佳大小分配一次，而且永远不会调整大小。
如果键值对的集合是固定的，并且是提前知道的（所以不允许插入和删除），人们可以通过仔细选择哈希函数、桶表大小和内部数据结构来降低平均查找成本。特别是，我们可以设计一个无碰撞的哈希函数，甚至是完美的哈希函数。在这种情况下，键不需要存储在表中 

如何避免一次性rehash？
一次性放大表的一个替代方法是逐步执行重合表。

    在调整大小的过程中，分配新的哈希表，但保持旧表不变。
    在每次查找或删除操作中，检查两个表。
    只在新表中执行插入操作。
    在每次插入时也将r个元素从旧表移到新表中。
    当所有的元素都从旧表中删除时，对其进行去分配。
为了保证在新表本身需要放大之前将旧表完全复制过来，在调整大小的过程中，有必要将表的大小至少增加一个系数（r+1）/r。

https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6/39980744#39980744

   
   