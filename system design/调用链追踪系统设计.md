# 论文导读
##  [So, you want to trace your distributed system? ][1]
调用链追踪系统需要解决的问题归类
异常检测。
分布式剖析。分布式剖析的目标是识别缓慢的组件或功能。
三种方法：
大多数端到端追踪基础设施使用三种方法中的一种来**识别因果关系的活动**：元数据传播、模式或黑箱推理。
- Metadata propagation: 
所有基于元数据传播的实现都能识别单个功能或跟踪点之间的因果关系，这些功能或跟踪点类似于日志信息，记录了系统中某一特定点在某一特定时间被达到的事实。为了将运行时间的开销（例如，响应时间和吞吐量的减慢）保持在最低限度，以便追踪可以 "一直在进行"，这一类的大多数追踪基础设施使用抽样，只收集少量的追踪点或工作流程。
- Schema-based:
不传播元数据，而是要求开发者编写时间连接模式，在自定义编写的日志信息中暴露的变量之间建立因果关系。基于模式的方法与采样不兼容，因为它们将确定什么是因果关系推迟到所有日志收集之后。因此，它们的可扩展性比元数据传播方法差。
- Black-box inference:
他们通过从预先存在的日志中关联变量或时间来推断因果关系，或者做出简化的假设。尽管在不修改软件的情况下获得端到端追踪的想法很吸引人，但这些方法在面对异步行为（如缓存、事件驱动系统）、并发、聚合或代码特定的设计模式（如2-3存储编码）时，无法正确归因，而这些都是分布式系统中常见的。

软件组件的工作是识别分布式系统中的工作，保留所选择的**因果关系**，限制开销，可选择将跟踪数据持续存储，创建跟踪，并向开发者展示跟踪。
它们包括:
- 各个跟踪点
- 因果追踪机制
- 采样机制
- 存储组件
- 跟踪构建代码
- 展示层
开发这样一个基础设施需要回答两个概念性的设计问题
- 哪些因果关系应该被保存下来？保留所有的因果关系会导致过多的开销，但保留错误的因果关系会产生无用的痕迹。
- 应该用什么模型来表达关系？有向无环树，表达顺序的、并发的或递归的调用/回复模式。

> Since preserving causally-related activity is the ultimate goal of end-to-end tracing, the ideal tracing infrastruc- ture would preserve all true or necessary causal relationships, and only those. For example, it would preserve the workflow of servicing individual requests and background activities, read-after-write accesses to memory, caches, files, and registers, data provenance, inter-request causal relationships due to resource contention (e.g., for caches) or built-up state, and so on.
由于保存因果关系的活动是端到端追踪的最终目标，理想的追踪基础设施将保存所有真实或必要的因果关系，而且只保存这些关系。例如，它将保留为单个请求和背景活动提供服务的工作流程，对内存、缓存、文件和寄存器的读写访问，数据出处，由于资源争夺（例如缓存）或建立状态而导致的请求间因果关系，等等。

> However, it is difficult to know what activities are truly causally related. As such, tracing infrastructures resort to preserving Lamport’s happens-before relation (), which states that if a and b are events and a  b, then a may have influenced b, and thus, b might be causally dependent on a [29](). But, the happens-before relation is only an approximation of true causality: it can be both too indiscriminate and incomplete at the same time. It can be incomplete because it is impossible to know all channels of influence, which can be outside of the system [12](). It can be too indiscriminate because it captures irrelevant causality, as may have influenced does not mean has influenced.
然而，很难知道哪些活动是真正有因果关系的。因此，追踪基础设施求助于保留Lamport的happen-before关系（），该关系指出，如果a和b是事件，a b，那么a可能影响了b，因此，b可能在因果上依赖于a [29]()。但是，happen-before关系只是真正的因果关系的一个近似值：它既可以是不加判断的，同样也可以是不完整的。它可能是不完整的，因为我们不可能知道所有的影响渠道，这些渠道可能在系统之外[12]()。它也可能太不分青红皂白，因为它抓住了不相关的因果关系，因为可能影响了并不意味着已经影响了。
> Tracing infrastructures limit indiscriminateness by using knowledge of the system being traced and the environment to capture only the slices of the general happens-before graph that are most likely to contain necessary causal relationships. First, most tracing infrastructures make assumptions about boundaries of influence among events. For example, by assuming a memory-protection model, the tracing infrastructure may exclude happens-before edges between activities in different processes, or even between different activities in a single-threaded event-based system (see Section 4 for mechanisms by which spurious edges are removed). Second, they may ask developers to explicitly add trace points in areas of the distributed system’s software they deem important and only track relationships between these trace points [11, 19, 20, 37, 40, 43, 47]().
追查基础设施通过使用被追查的系统和环境的知识，只捕捉最有可能包含必要因果关系的一般发生前图的片断，从而限制了无差别性。首先，大多数追踪基础设施对事件之间的影响界限进行了假设。例如，通过假设一个内存保护模型，追踪基础设施可能会排除不同进程中的活动之间，甚至是基于事件的单线程系统中的不同活动之间的发生前边缘（关于去除虚假边缘的机制见第4节）。其次，他们可能要求开发者在他们认为重要的分布式系统软件区域明确地添加跟踪点，并且只跟踪这些跟踪点之间的关系[11, 19, 20, 37, 40, 43, 47]()。
> Different slices are useful for different use cases, but preserving all of them would incur too much overhead (even the most efficient software taint-tracking mechanisms yield a 2x to 8x slowdown [26]()). As such, tracing infrastructures work to preserve only the slices that are most useful for how their outputs will be used. The rest of this section describes slices that have proven useful for various use cases.
不同的片断对不同的用例是有用的，但保留所有的片断会产生太多的开销（即使是最有效的软件污点追踪机制也会产生2到8倍的减速[26]()）。因此，跟踪基础设施的工作是只保留对其输出的使用方式最有用的片断。本节的其余部分描述了已被证明对各种使用情况有用的片断。
## 3.1 请求内片断
> When developing a tracing infrastructure, developers must choose a slice of the happens-before graph that defines the workflow of a request as it is being serviced by a distributed system. Work created by the submitting request that is performed before the request responds to the client must be considered part of its workflow. However, latent work (e.g., data left in a write-back cache that must be written to disk eventually) can either be considered part of the submitting request’s workflow or part of the request that forces that work to be executed (e.g., via an on-demand cache eviction). This observation forms the basis for two intra-request slices—submitter-preserving and trigger-preserving—that preserve different information and are useful for different use cases. We first identified these slices and the differences between them while trying to understand why the original Stardust [47]() wasn’t useful for diagnosis tasks.
在开发追踪基础设施时，开发者必须选择一个发生前图的片断，该片断定义了一个请求在被分布式系统服务时的工作流程。由提交的请求所创造的、在请求响应客户端之前执行的工作必须被视为其工作流程的一部分。然而，潜伏的工作（例如，留在回写缓存中的数据，最终必须写入磁盘）可以被视为提交请求的工作流程的一部分，或者是强制执行该工作的请求的一部分（例如，通过按需缓存驱逐）。这一观察形成了两个请求内切片的基础--提交者保留和触发者保留--它们保留了不同的信息，对不同的用例是有用的。我们首先确定了这些片断以及它们之间的区别，同时试图理解为什么最初的Stardust[47]()对诊断任务没有用。
> Section 3.1.1 and Section 3.1.2 describe the tradeoffs involved in preserving the submitter-preserving and trigger-preserving slices in more detail. Section 3.1.3 lists the advantages of preserving both intra-request slices. Section 3.1.4 discusses the benefits of delineating concurrent behaviour from sequential behaviour and preserving forks and joins in individual traces. Table 2 shows intra-request slices most useful for the key uses of end-to-end tracing.
第3.1.1节和第3.1.2节更详细地描述了保存提交者保存片和触发者保存片所涉及的权衡。第3.1.3节列出了保留两个请求内片的优点。第3.1.4节讨论了从顺序行为中划分出并发行为的好处，以及保留单个跟踪中的分叉和连接的好处。表2显示了对端到端追踪的主要用途最有用的请求内片断。

### 3.1.1 The submitter-preserving slice
> Preserving this slice means that individual end-to-end traces will show causality between the original submitter of a request and work done to process it through every component of the system. It is most useful for resource attribution, since this usage mode requires that end-to-end traces tie the work done at a component several levels deep in the system to the client, workload, or request responsible for originally submitting it. Quanto [18](), Whodunit [9](), and the original version of Stardust [47]() preserve this slice of causality. The two leftmost diagrams in Figure 3 show submitter-preserving traces for two write requests in a distributed storage system. Request one writes data to the system’s cache and immediately replies. Sometime later, request two enters the system and must evict request one’s data to place its data in the cache. To preserve submitter causality, the tracing infrastructure attributes the work done for the eviction to request one, not request two. Request two’s trace only shows the latency of the eviction. Note that the tracing infrastructure would attribute work the same way if request two were a background cleaner thread instead of a client request that causes an on-demand eviction.
保存这个片断意味着单个端到端追踪将显示一个请求的原始提交者和通过系统的每个组件处理该请求所做的工作之间的因果关系。这对于资源归属是最有用的，因为这种使用模式要求端到端追踪将系统中几层的组件所做的工作与负责最初提交的客户端、工作负载或请求联系起来。Quanto、Whodunit 和 Stardust 的原始版本保留了这种因果关系的切片。图3中最左边的两张图显示了一个分布式存储系统中两个写请求的提交者保留的痕迹。请求 1 将数据写到系统的缓存中，并立即进行回复。稍后，请求 2 进入系统，必须驱逐请求 1 的数据，将其数据放入缓存。为了保持提交者的因果关系，追踪基础设施将驱逐的工作归于请求 1，而不是请求 2 。请求 2的追踪只显示驱逐的延迟。请注意，如果请求 2 是一个后台清洁器线程，而不是一个导致按需驱逐的客户端请求，那么追踪基础设施将以同样的方式进行归因。
### 3.1.2 The trigger-preserving slice
> The submitter-preserving trace for request one shown in Figure 3 is unintuitive and hard to understand when visualized because it attributes work done to the request after the client reply has been sent. Also, latent work attributed to this request (i.e., trace points executed after the reply is sent) is performed in the critical path of request two. In contrast, trigger causality guarantees that a trace of a request will show all work that must be performed before a client response can be sent, including another client’s latent work if it is executed in the request’s critical path. The right two traces in Figure 3 show the same two requests as in the submitter- preserving example, with trigger causality preserved instead. Since these traces are easier to understand when visualized (they always end with a client reply) and always show all work done on requests’ critical paths, trigger causality should be preserved for diagnosis tasks, which often involve answering questions of the form
> “Why is this request so slow?”
> Indeed, switching from preserving submitter causality to preserving trigger causality was perhaps the
> most important change we made to the original version of Stardust [47]() (useful for resource attribution) to make it useful for diagnosis tasks [40](). Many other tracing implementations implicitly preserve this slice of causality [11, 19, 37, 43]().

图3所示的请求 1 的提交者保留跟踪是不直观的，而且在可视化时很难理解，因为它将请求的工作归结为客户端回复发送后的结果。而且，归属于该请求的潜在工作（即在发送回复后执行的跟踪点）是在请求 2 的关键路径上执行的。相比之下，触发因果关系保证了一个请求的跟踪将显示所有在客户端响应发送前必须执行的工作，包括另一个客户端的潜在工作，如果它是在请求的关键路径上执行的。图3中右边的两个跟踪显示了与提交者保存的例子中相同的两个请求，但保留了触发因果关系。由于这些轨迹在可视化时更容易理解（它们总是以客户的回复结束），并且总是显示在请求的关键路径上所做的所有工作，所以在诊断任务中应该保留触发因果关系，这通常涉及回答以下问题
"为什么这个请求这么慢？"
事实上，从保留提交者的因果关系到保留触发者的因果关系，也许是我们对原始系统做出的最重要的改变。
我们对Stardust[47]()的原始版本（对资源归属有用）所做的最重要的改变，使其对诊断任务有用[40]()。许多其他的追踪实现隐含地保留了这一片的因果关系[11, 19, 37, 43]()。
![][image-1]

### 3.1.3 Is anything gained by preserving both?
> The slices suggested above are the most important ones that should be preserved for various use cases, not the only ones that should be preserved. Indeed, preserving both submitter causality and trigger causality will enable a deeper understanding of the distributed system than is possible by preserving only one of them. For example, for diagnosis, preserving submitter causality in addition to trigger causality will allow the tracing infrastructure to answer questions such as “Who was responsible for evicting my client’s cached data?” or, more generally, “Which clients tend to interfere with each other most?”
3.1.3 保留两者有什么好处吗？
上面建议的片断是对各种用例应该保留的最重要的片断，而不是唯一应该保留的片断。事实上，同时保留提交者的因果关系和触发者的因果关系将使我们对分布式系统的理解比只保留其中一个更深入。例如，对于诊断来说，除了保留**提交者因果**关系外，还保留**触发者因果关系**将使追踪基础设施能够回答诸如 "谁负责驱逐我的客户的缓存数据？"或者，更广泛地说，"哪些客户最倾向于互相干扰？"

### 3.1.4 Preserving workflow structure (concurrency, forks, and joins)

> For both submitter-preserving causality and trigger-preserving causality, preserving workflow structure— concurrent behaviour, forks, and joins—is optional. It is not necessary for some use cases, such as resource attribution or profiling. However, it is useful to preserve them for diagnosis tasks. Preserving concurrency and forks allows developers to diagnose problems due to excessive parallelism or too little parallelism. Additionally, preserving joins allows developers to diagnose excessive waiting at synchronization points and allows them to easily identify critical paths.
> The original version of X-Trace [20]() used trees to model causal relationships and so could not preserve joins. The original version of Stardust [47]() used DAGs, but did not instrument joins. To become more useful for diagnosis tasks, in their revised versions [19,40](), X-Trace evolved to use DAGs and both evolved to explicitly include APIs for instrumenting joins.

对于提交者保留因果关系和触发者保留因果关系，**保留工作流结构**--并发行为、forks 和joins — 是可选的。对于某些用例，如 resource attribution 或 profiling（侧写），它并不是必须的。然而，对于诊断任务来说，保留它们是有用的。保留并发行为和 fork 允许开发者诊断由于过度并行或太少并行而产生的问题。此外，保留连接允许开发人员诊断在同步点上的过度等待，并允许他们轻松识别关键路径。
X-Trace[20]()的原始版本使用**树**来模拟因果关系，所以不能保留连接。Stardust[47]()的原始版本使用了**DAG**，但没有记录连接。为了对诊断任务更加有用，在它们的修订版本[19,40]()中，X-Trace演化为使用DAGs，并且两者都演化为明确地包括用于测量连接的API。

## 3.2 Preserving inter-request slices
> In addition to relationships within a request, many types of causal relationships may exist between requests. This section describes the two most common ones.
> The contention-preserving slice: Requests may compete with each other for resources, such as access to a shared variable. Preserving causality between requests holding a resource lock and those waiting for it can help explain unexpected performance slowdowns or timeouts. Only Whodunit [9]() preserves this slice.
> The-read-after-write-preserving slice: Requests that read data (e.g., from a cache or file) written by others may be causally affected by the contents. For example, a request that performs work dictated by the contents of a file—e.g., a map-reduce job [15]()—may depend on that file’s original writer. Preserving read-after-write dependencies can help explain such requests’ behaviour.

除了一个请求内的关系外，许多类型的因果关系可能存在于请求之间。本节描述了两种最常见的关系。
保留竞争（contention-preserving）的片断。请求可能会相互竞争资源，例如对共享变量的访问。保存持有资源锁的请求和等待资源锁的请求之间的因果关系，有助于解释意外的性能减慢或超时。只有Whodunit[9]()保留了这个片断。
读取-写入后（The-read-after-write-preserving）的保留片断。读取他人写入的数据（例如，从缓存或文件）的请求可能会受到内容的因果影响。例如，一个执行由文件内容决定的工作的请求--如map-reduce作业[15]()--可能依赖于该文件的原始写作者。保存读写依赖关系可以帮助解释这种请求的行为。

[1]:	https://www.pdl.cmu.edu/PDL-FTP/SelfStar/CMU-PDL-14-102.pdf


[image-1]:	https://tva1.sinaimg.cn/large/008i3skNgy1gsv8f337f5j30w00gugo4.jpg