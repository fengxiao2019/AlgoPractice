## 反向依赖
变动方是A，配合方却是BCDE，也就是一处变动，多处都要跟着改动。eg: 想想“换IP的是你，配合重启的却是我”更好理解
## 常见场景以及优化手段
### 场景1 公共的库导致的耦合
A B  C 都使用了公共库M，一个业务改了公共库M，导致ABC都要跟着改动。
#### 方案1： 垂直拆分公共库
垂直拆分。将公共库中业务特性比较强的部分拆分成多个库，减少依赖项。
#### 方案2: 服务化
如果公共库的共性很强，可以将其服务化，服务化之后，兼容性能更好的通过接口自动化回归测试来保证。
基础服务的抽象，本身是一种共性聚焦，是系统解耦常见的方案。
### 服务化不彻底导致的耦合
特征：服务中包含大量“根据不同业务，执行不同分支”的代码
优化方案：分支代码上浮到业务层实现，将服务化更彻底更纯粹
### notify的不合理实现导致的耦合
特征：调用方不关注执行结果，以调用的方式去实现通知，新增订阅者，修改代码的是发布者
优化方案：通过MQ解耦
### 配置中的ip导致上下游耦合
特征：多个上游需要修改配置重启
优化方案：使用内网域名替代内网ip，通过“修改DNS指向，统一切断旧连接”的方式来上游无感切换

### 下游扩容导致上下游耦合
特性：多个上游需要修改配置重启
利用配置中心解决藕合
配置中心是一个典型的逻辑上解耦、物理上不解耦(上下游依然得建立连接)的一个架构优化工具
要点：
- 所有通用配置，基础配置将由配置中心统一维护，数据只存储一份，不再有“配置私藏”
- 所有上游通过配置中心来订阅下游配置
- 所有下游的配置变更，例如扩容时，通过配置中心统一修改
- 配置中心将变更后的配置通知所有上游订阅方
- 订阅方得知下游服务扩容或者缩容后，通过动态连接池，自动新增或者销毁连接，实现自动扩容与缩容，大部分服务发现都是这么做的
引用
[https://www.w3cschool.cn/architectroad/architectroad-reverse-dependency-and-decoupling.html][1]

[1]:	https://www.w3cschool.cn/architectroad/architectroad-reverse-dependency-and-decoupling.html