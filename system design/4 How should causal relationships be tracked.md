# 4 How should causal relationships be tracked?
> All end-to-end tracing infrastructures must employ a mechanism to track the slices of intra-request and inter-request causality most relevant to their intended use cases. To avoid capturing superfluous relationships (e.g., portions of undesired slices or false causal relationships), tracing infrastructures â€œthreadâ€ metadata along with individual workflows and establish happens-before relationships only to items with the same (or related) metadata [9, 11, 19, 20, 37, 40, 43, 47, 48](). Section 4.1 describes different types of metadata and tradeoffs between them.
æ‰€æœ‰çš„ç«¯åˆ°ç«¯è¿½è¸ªåŸºç¡€è®¾æ–½å¿…é¡»é‡‡ç”¨ä¸€ç§æœºåˆ¶æ¥è¿½è¸ªä¸ä»–ä»¬çš„é¢„æœŸç”¨ä¾‹æœ€ç›¸å…³çš„`intra-request` å’Œ `inter-request` çš„å› æœå…³ç³»ç‰‡æ–­ã€‚ä¸ºäº†é¿å…æ•è·å¤šä½™çš„å…³ç³»ï¼ˆä¾‹å¦‚ï¼Œä¸éœ€è¦çš„éƒ¨åˆ†ç‰‡æ–­æˆ–é”™è¯¯çš„å› æœå…³ç³»ï¼‰ï¼Œè¿½è¸ªåŸºç¡€è®¾æ–½å°†å…ƒæ•°æ®ä¸å•ä¸ªå·¥ä½œæµç¨‹ "ä¸²è” "èµ·æ¥ï¼Œå¹¶ä»…å¯¹**å…·æœ‰ç›¸åŒï¼ˆæˆ–ç›¸å…³ï¼‰å…ƒæ•°æ®çš„é¡¹ç›®**å»ºç«‹`happens-before`å…³ç³»[9, 11, 19, 20, 37, 40, 43, 47, 48]()ã€‚ç¬¬4.1èŠ‚æè¿°äº†ä¸åŒç±»å‹çš„å…ƒæ•°æ®å’Œå®ƒä»¬ä¹‹é—´çš„æƒè¡¡ã€‚
> In general, metadata can be propagated by storing it in thread-local variables when a single thread is performing causally-related work, and encoding logic to propagate metadata across boundaries (e.g., across threads, caches, or components) in commonly used libraries. We argue that systems should be designed with the ability to propagate reasonably generic metadata with their flow of execution and messages, as this is a key underlying primitive of all tracing infrastructures we describe.
ä¸€èˆ¬æ¥è¯´ï¼Œå½“å•ä¸ªçº¿ç¨‹æ‰§è¡Œå› æœå…³ç³»çš„å·¥ä½œæ—¶ï¼Œ**å…ƒæ•°æ®**å¯ä»¥é€šè¿‡å­˜å‚¨åœ¨`thread-local`ä¸­æ¥ä¼ æ’­ï¼Œå¹¶åœ¨å¸¸ç”¨çš„åº“ä¸­**åŸ‹ç‚¹**æ¥è·¨è¾¹ç•Œï¼ˆä¾‹å¦‚è·¨çº¿ç¨‹ã€ç¼“å­˜æˆ–ç»„ä»¶ï¼‰ä¼ æ’­å…ƒæ•°æ®ã€‚æˆ‘ä»¬è®¤ä¸ºï¼Œç³»ç»Ÿåº”è¯¥è¢«è®¾è®¡æˆæœ‰èƒ½åŠ›å°†åˆç†çš„é€šç”¨å…ƒæ•°æ®ä¸ä»–ä»¬çš„æ‰§è¡Œæµå’Œæ¶ˆæ¯ä¸€èµ·ä¼ æ’­ï¼Œå› ä¸ºè¿™æ˜¯æˆ‘ä»¬æè¿°çš„æ‰€æœ‰è¿½è¸ªåŸºç¡€è®¾æ–½çš„ä¸€ä¸ªå…³é”®çš„åŸºæœ¬è¦ç´ ã€‚
> Though any of the approaches discussed below can preserve concurrency by establishing happens-before relationships, additional instrumentation is needed to capture forks and joins. Such structural trace points are discussed in Section 4.2. Of course, the causal-relationship model used by the tracing infrastructure must also be expressive enough to represent concurrency, forks, and joins.
å°½ç®¡ä¸‹é¢è®¨è®ºçš„ä»»ä½•æ–¹æ³•éƒ½å¯ä»¥é€šè¿‡å»ºç«‹`happen-before`çš„å…³ç³»æ¥ä¿å­˜å¹¶å‘æ€§ï¼Œä½†éœ€è¦é¢å¤–çš„å·¥å…·æ¥æ•è·`fork`å’Œ`join`ã€‚è¿™æ ·çš„ç»“æ„æ€§è·Ÿè¸ªç‚¹å°†åœ¨ç¬¬4.2èŠ‚è®¨è®ºã€‚å½“ç„¶ï¼Œè¿½è¸ªåŸºç¡€è®¾æ–½æ‰€ä½¿ç”¨çš„å› æœå…³ç³»æ¨¡å‹ä¹Ÿå¿…é¡»æœ‰è¶³å¤Ÿçš„è¡¨ç°åŠ›æ¥è¡¨ç¤ºå¹¶å‘æ€§ã€`fork` å’Œ`join`ã€‚

## 4.1 Tradeoffs between metadata types
4.1 å…ƒæ•°æ®ç±»å‹ä¹‹é—´çš„æƒè¡¡
> Per-workflow metadata can either be static or dynamic. Dynamic metadata can additionally be fixed-width or variable-width. There are three main issues to consider when determining which type of metadata to use. First is size. Larger metadata will result in larger messages (e.g., RPCs) or will constrain payload size. Second is brittleness (or resilience) to lost or unavailable data. Third is whether the approach enables immediate availability of full traces (or other data needed for analysis) without trace construction.
æ¯ä¸ªå·¥ä½œæµçš„å…ƒæ•°æ®å¯ä»¥æ˜¯é™æ€çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯åŠ¨æ€çš„ã€‚åŠ¨æ€å…ƒæ•°æ®è¿˜å¯ä»¥æ˜¯å›ºå®šå®½åº¦æˆ–å¯å˜å®½åº¦çš„ã€‚åœ¨å†³å®šä½¿ç”¨å“ªç§ç±»å‹çš„å…ƒæ•°æ®æ—¶ï¼Œæœ‰ä¸‰ä¸ªä¸»è¦é—®é¢˜éœ€è¦è€ƒè™‘ï¼šé¦–å…ˆæ˜¯å°ºå¯¸ï¼ˆsizeï¼‰ï¼Œè¾ƒå¤§çš„å…ƒæ•°æ®ä¼šå¯¼è‡´è¾ƒå¤§çš„æ¶ˆæ¯ï¼ˆä¾‹å¦‚RPCsï¼‰ï¼Œæˆ–è®¸ä¼šé™åˆ¶æœ‰æ•ˆè´Ÿè½½çš„å¤§å°ã€‚ğŸ˜¡_ç¬¬äºŒæ˜¯å¯¹ä¸¢å¤±æˆ–ä¸å¯ç”¨çš„æ•°æ®çš„è„†æ€§ï¼ˆæˆ–å¤åŸåŠ›ï¼‰_ ğŸ˜¡ã€‚ç¬¬ä¸‰æ˜¯è¯¥æ–¹æ³•æ˜¯å¦èƒ½å¤Ÿåœ¨ä¸å»ºç«‹è·Ÿè¸ªçš„æƒ…å†µä¸‹ç«‹å³æä¾›å®Œæ•´çš„è·Ÿè¸ªï¼ˆæˆ–åˆ†ææ‰€éœ€çš„å…¶ä»–æ•°æ®ï¼‰ã€‚
> Comparing the three approaches, fixed-width approaches limit metadata size compared to variable-width approaches. All fixed-width approaches are also brittle to data availability or loss, though in different ways and to differing degrees. Dynamic, variable-width approaches can be extremely resilient to data loss, but at the cost of metadata size. Additionally, dynamic, variable-width approaches are often necessary to avoid trace construction. Table 3 summarizes the tradeoffs between the various metadata-propagation approaches. The rest of this section describes them in more detail.
å¯¹æ¯”è¿™ä¸‰ç§æ–¹æ³•ï¼Œ**å›ºå®šå®½åº¦çš„æ–¹æ³•**æ¯”**å¯å˜å®½åº¦çš„æ–¹æ³•**é™åˆ¶äº†å…ƒæ•°æ®çš„å¤§å°ã€‚æ‰€æœ‰çš„å›ºå®šå®½åº¦æ–¹æ³•å¯¹æ•°æ®çš„å¯ç”¨æ€§æˆ–ä¸¢å¤±ä¹Ÿå¾ˆè„†å¼±ï¼Œå°½ç®¡æ–¹å¼ä¸åŒï¼Œç¨‹åº¦ä¹Ÿä¸åŒã€‚åŠ¨æ€çš„ã€å¯å˜å®½åº¦çš„æ–¹æ³•å¯ä»¥å¯¹æ•°æ®ä¸¢å¤±æœ‰æå¤§çš„å¼¹æ€§ï¼Œä½†æ˜¯ä»¥å…ƒæ•°æ®å¤§å°ä¸ºä»£ä»·ã€‚æ­¤å¤–ï¼ŒåŠ¨æ€çš„ã€å¯å˜å®½åº¦çš„æ–¹æ³•æ›´é€‚ç”¨äº**é¿å…è¿½è¸ªçš„æ„å»ºï¼Ÿï¼Ÿ**ã€‚è¡¨3æ€»ç»“äº†å„ç§å…ƒæ•°æ®ä¼ æ’­æ–¹æ³•ä¹‹é—´çš„æƒè¡¡ã€‚æœ¬èŠ‚çš„å…¶ä½™éƒ¨åˆ†å°†æ›´è¯¦ç»†åœ°æè¿°å®ƒä»¬ã€‚
> **Static, fixed-width metadata**: With this approach, a single metadata value (e.g., a randomly chosen 64-bit workflow ID) is used to identify all causally-related activity. Tracing implementations that use this method must explicitly construct traces by joining trace-point records with the same metadata. When doing so, they must rely on clues stored with trace-point records to establish happens-before relationships. For example, to order causally-related activity within a single thread, they must rely on an external clock. Since network messages must always be sent by a client before being received by a server, tracing infrastructures that do not rely on synchronized clocks might establish happens-before relationships between client and server work using network send and receive trace points on both machines. To identify concurrent work within components, tracing implementations that use this approach might establish happens-before relationship via thread IDs. Pip [37](), Pinpoint [11](), and Quanto [18]() use static, fixed-width metadata.
**é™æ€çš„ã€å›ºå®šå®½åº¦çš„å…ƒæ•°æ®**: é‡‡ç”¨è¿™ç§æ–¹æ³•ï¼Œä¸€ä¸ªå•ä¸€çš„å…ƒæ•°æ®å€¼ï¼ˆä¾‹å¦‚ï¼Œéšæœºé€‰æ‹©çš„64ä½å·¥ä½œæµIDï¼‰è¢«ç”¨æ¥è¯†åˆ«æ‰€æœ‰ä¸å› æœç›¸å…³çš„æ´»åŠ¨ã€‚ä½¿ç”¨è¿™ç§æ–¹æ³•çš„è¿½è¸ªå®ç°å¿…é¡»é€šè¿‡è¿æ¥å…·æœ‰ç›¸åŒå…ƒæ•°æ®çš„è¿½è¸ªç‚¹è®°å½•æ¥æ˜ç¡®åœ°æ„å»ºè¿½è¸ªã€‚åœ¨è¿™æ ·åšçš„æ—¶å€™ï¼Œä»–ä»¬å¿…é¡»ä¾é ä¸è·Ÿè¸ªç‚¹è®°å½•ä¸€èµ·å­˜å‚¨çš„çº¿ç´¢æ¥å»ºç«‹`happens-before`çš„å…³ç³»ã€‚ä¾‹å¦‚ï¼Œä¸ºäº†åœ¨ä¸€ä¸ªå•ä¸€çš„çº¿ç¨‹ä¸­æ’åˆ—å› æœå…³ç³»çš„æ´»åŠ¨ï¼Œä»–ä»¬å¿…é¡»ä¾é å¤–éƒ¨æ—¶é’Ÿã€‚ç”±äºç½‘ç»œä¿¡æ¯åœ¨è¢«æœåŠ¡å™¨æ¥æ”¶ä¹‹å‰å¿…é¡»å…ˆç”±å®¢æˆ·ç«¯å‘é€ï¼Œæ‰€ä»¥ä¸ä¾èµ–åŒæ­¥æ—¶é’Ÿçš„è¿½è¸ªåŸºç¡€è®¾æ–½å¯ä»¥ä½¿ç”¨ä¸¤å°æœºå™¨ä¸Šçš„ç½‘ç»œå‘é€å’Œæ¥æ”¶è¿½è¸ªç‚¹æ¥å»ºç«‹å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨å·¥ä½œä¹‹é—´çš„å‘ç”Ÿå‰å…³ç³»ã€‚ä¸ºäº†è¯†åˆ«ç»„ä»¶å†…çš„å¹¶å‘å·¥ä½œï¼Œä½¿ç”¨è¿™ç§æ–¹æ³•çš„è¿½è¸ªå®ç°å¯ä»¥é€šè¿‡çº¿ç¨‹IDå»ºç«‹å‘ç”Ÿå‰çš„å…³ç³»ã€‚Pip[37]()ã€Pinpoint[11]()å’ŒQuanto[18]()ä½¿ç”¨é™æ€ã€å›ºå®šå®½åº¦çš„å…ƒæ•°æ®ã€‚
> This approach is brittle because it will be unable to properly order activity in cases where the external clues are lost (e.g., due to losing trace-point records) or are unavailable (e.g., because developers are not blessed with the ability to modify arbitrary sections of the distributed systemâ€™s codebase). For example, if thread IDs are lost or are not available, this approach might not be able to properly identify concurrent activity within a component.
è¿™ç§æ–¹æ³•æ˜¯è„†å¼±çš„ï¼Œå› ä¸ºåœ¨å¤–éƒ¨çº¿ç´¢ä¸¢å¤±ï¼ˆä¾‹å¦‚ï¼Œç”±äºä¸¢å¤±è·Ÿè¸ªç‚¹è®°å½•ï¼‰æˆ–ä¸å¯ç”¨ï¼ˆä¾‹å¦‚ï¼Œç”±äºå¼€å‘äººå‘˜æ²¡æœ‰èƒ½åŠ›ä¿®æ”¹åˆ†å¸ƒå¼ç³»ç»Ÿä»£ç åº“çš„ä»»æ„éƒ¨åˆ†ï¼‰çš„æƒ…å†µä¸‹ï¼Œå®ƒå°†æ— æ³•æ­£ç¡®æ’åºæ´»åŠ¨ã€‚ä¾‹å¦‚ï¼Œå¦‚æœçº¿ç¨‹IDä¸¢å¤±æˆ–ä¸å¯ç”¨ï¼Œè¿™ç§æ–¹æ³•å¯èƒ½æ— æ³•æ­£ç¡®è¯†åˆ«ä¸€ä¸ªç»„ä»¶å†…çš„å¹¶å‘æ´»åŠ¨ã€‚

> **Dynamic, fixed-width metadata**: With this approach, simple logical clocks (i.e., single 64-bit values), in addition to a workflow ID, can be embedded within metadata, enabling tracing infrastructures to encode happens-before relationships without relying on external clues. To limit metadata size, a single logical times- tamp is used. Vector clocks are not feasible with fixed-width metadata because they would require metadata as wide as the number of threads in the entire distributed system. At each trace point, a new random logical-clock value is chosen and a happens-before relationship is created by storing both new and old logical-clock values in the corresponding trace record. Counters that are incremented at each trace point could also be used to implement logical clocks, but would be insufficient for ordering concurrent accesses. Both versions of X-Trace [19, 20]() use dynamic, fixed-width metadata. Dapper [43]() and both versions of Stardust [40, 47]() use a hybrid approach that combines the previous approach and this one. For example, Stardust [40, 47]() relies on an external clock to order activity within components and uses logical clocks to order inter-component accesses.
åŠ¨æ€ã€å›ºå®šå®½åº¦çš„å…ƒæ•°æ®: é€šè¿‡è¿™ç§æ–¹æ³•ï¼Œé™¤äº†å·¥ä½œæµIDä¹‹å¤–ï¼Œç®€å•çš„é€»è¾‘æ—¶é’Ÿï¼ˆå³å•ä¸ª64ä½å€¼ï¼‰å¯ä»¥åµŒå…¥åˆ°å…ƒæ•°æ®ä¸­ï¼Œä½¿è¿½è¸ªåŸºç¡€è®¾æ–½èƒ½å¤Ÿåœ¨ä¸ä¾èµ–å¤–éƒ¨çº¿ç´¢çš„æƒ…å†µä¸‹ç¼–ç `happens-before` å…³ç³»ã€‚ä¸ºäº†é™åˆ¶å…ƒæ•°æ®çš„å¤§å°ï¼Œä½¿ç”¨äº†ä¸€ä¸ªå•ä¸€çš„é€»è¾‘æ—¶é—´æˆ³ã€‚çŸ¢é‡æ—¶é’Ÿåœ¨å›ºå®šå®½åº¦çš„å…ƒæ•°æ®ä¸­æ˜¯ä¸å¯è¡Œçš„ï¼Œå› ä¸ºå®ƒä»¬éœ€è¦çš„å…ƒæ•°æ®å®½åº¦ä¸æ•´ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„çº¿ç¨‹æ•°ä¸€æ ·å¤§ã€‚åœ¨æ¯ä¸ªè·Ÿè¸ªç‚¹ï¼Œé€‰æ‹©ä¸€ä¸ªæ–°çš„éšæœºé€»è¾‘æ—¶é’Ÿå€¼ï¼Œå¹¶é€šè¿‡åœ¨ç›¸åº”çš„è·Ÿè¸ªè®°å½•ä¸­å­˜å‚¨æ–°çš„å’Œæ—§çš„é€»è¾‘æ—¶é’Ÿå€¼æ¥åˆ›å»ºä¸€ä¸ª`happens-before`å…³ç³»ã€‚åœ¨æ¯ä¸ªè·Ÿè¸ªç‚¹ä¸Šé€’å¢çš„è®¡æ•°å™¨ä¹Ÿå¯ä»¥ç”¨æ¥å®ç°é€»è¾‘æ—¶é’Ÿï¼Œä½†ä¸è¶³ä»¥å¯¹å¹¶å‘è®¿é—®è¿›è¡Œæ’åºã€‚X-Trace[19, 20]()çš„ä¸¤ä¸ªç‰ˆæœ¬éƒ½ä½¿ç”¨åŠ¨æ€çš„ã€å›ºå®šå®½åº¦çš„å…ƒæ•°æ®ã€‚Dapper[43]()å’ŒStardust[40, 47]()çš„ä¸¤ä¸ªç‰ˆæœ¬éƒ½ä½¿ç”¨äº†ä¸€ç§æ··åˆæ–¹æ³•ï¼Œç»“åˆäº†å‰ä¸€ç§æ–¹æ³•å’Œè¿™ç§æ–¹æ³•ã€‚ä¾‹å¦‚ï¼ŒStardust [40, 47]() ä¾é å¤–éƒ¨æ—¶é’Ÿæ¥å®‰æ’ç»„ä»¶å†…çš„æ´»åŠ¨ï¼Œå¹¶ä½¿ç”¨é€»è¾‘æ—¶é’Ÿæ¥å®‰æ’ç»„ä»¶é—´çš„è®¿é—®ã€‚

> The dynamic, fixed-width approach is also brittle because it cannot easily order trace-point records when a subset of them are lost. For example, if a single trace-point record is lost, this approach will be unable to order the two trace fragments that surround it because both will have completely different logical-clock values for which no explicit happens-before relationship exists. Hybrid approaches, which do not change metadata values as often, are slightly less susceptible to this problem than approaches that always change metadata between trace points. Other approaches are also possible to reduce brittleness, but at the expense of space.
åŠ¨æ€çš„ã€å›ºå®šå®½åº¦çš„æ–¹æ³•ä¹Ÿæ˜¯å¾ˆè„†çš„ï¼Œå› ä¸ºå½“å…¶ä¸­çš„ä¸€ä¸ªå­é›†ä¸¢å¤±æ—¶ï¼Œå®ƒä¸èƒ½è½»æ˜“åœ°å¯¹è·Ÿè¸ªç‚¹è®°å½•è¿›è¡Œæ’åºã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªè·Ÿè¸ªç‚¹è®°å½•ä¸¢å¤±äº†ï¼Œè¿™ç§æ–¹æ³•å°†æ— æ³•å¯¹å›´ç»•å®ƒçš„ä¸¤ä¸ªè·Ÿè¸ªç‰‡æ®µè¿›è¡Œæ’åºï¼Œå› ä¸ºè¿™ä¸¤ä¸ªç‰‡æ®µçš„é€»è¾‘æ—¶é’Ÿå€¼å®Œå…¨ä¸åŒï¼Œä¸å­˜åœ¨æ˜ç¡®çš„`happens-before`å…³ç³»ã€‚æ··åˆæ–¹æ³•ï¼Œä¸ç»å¸¸æ”¹å˜å…ƒæ•°æ®å€¼ï¼Œæ¯”èµ·æ€»æ˜¯åœ¨è¿½è¸ªç‚¹ä¹‹é—´æ”¹å˜å…ƒæ•°æ®çš„æ–¹æ³•ï¼Œå¯¹è¿™ä¸ªé—®é¢˜çš„æ•æ„Ÿåº¦ç•¥ä½ã€‚å…¶ä»–æ–¹æ³•ä¹Ÿæœ‰å¯èƒ½å‡å°‘è„†æ€§ï¼Œä½†è¦ä»¥ç‰ºç‰²ç©ºé—´ä¸ºä»£ä»·ã€‚
![][image-1]
> Table 3: Tradeoffs between metadata types. Static and dynamic, fixed-width approaches are of constant size (e.g., a minimum of one or two 64-bit values), but are brittle and do not enable immediate use of trace data. Dynamic variable- width approaches can enable resiliency by incorporating [interval-treeÂ ][17]clocks and can be used to obtain traces immediately, but the resulting metadata can be very large (e.g., its size could be proportional to the amount of intra-request concurrency and number of functions executed). Hybrid approaches represent a good inflection point because they are less brittle than pure static or dynamic approaches and are of constant size (e.g., a minimum of two 64-bit values).
è¡¨3ï¼šå…ƒæ•°æ®ç±»å‹ä¹‹é—´çš„æƒè¡¡ã€‚é™æ€å’ŒåŠ¨æ€çš„å›ºå®šå®½åº¦çš„æ–¹æ³•æ˜¯æ’å®šçš„å¤§å°ï¼ˆä¾‹å¦‚ï¼Œæœ€å°çš„ä¸€ä¸ªæˆ–ä¸¤ä¸ª64ä½çš„å€¼ï¼‰ï¼Œä½†æ˜¯å¾ˆè„†å¼±ï¼Œä¸èƒ½ç«‹å³ä½¿ç”¨è·Ÿè¸ªæ•°æ®ã€‚åŠ¨æ€å˜å®½æ–¹æ³•å¯ä»¥é€šè¿‡æ•´åˆåŒºé—´æ ‘æ—¶é’Ÿæ¥å®ç°å¼¹æ€§ï¼Œå¹¶ä¸”å¯ä»¥ç”¨æ¥ç«‹å³è·å¾—è·Ÿè¸ªæ•°æ®ï¼Œä½†æ˜¯äº§ç”Ÿçš„å…ƒæ•°æ®å¯èƒ½éå¸¸å¤§ï¼ˆä¾‹å¦‚ï¼Œå…¶å¤§å°å¯èƒ½ä¸è¯·æ±‚å†…å¹¶å‘é‡å’Œæ‰§è¡Œçš„å‡½æ•°æ•°é‡æˆæ­£æ¯”ï¼‰ã€‚æ··åˆæ–¹æ³•ä»£è¡¨äº†ä¸€ä¸ªå¾ˆå¥½çš„æ‹ç‚¹ï¼Œå› ä¸ºå®ƒä»¬æ¯”çº¯ç²¹çš„é™æ€æˆ–åŠ¨æ€æ–¹æ³•æ›´å¥å£®ï¼ˆä¸è„†å¼±ï¼‰ï¼Œè€Œä¸”å¤§å°æ’å®šï¼ˆä¾‹å¦‚ï¼Œæœ€å°ä¸ºä¸¤ä¸ª64ä½çš„å€¼ï¼‰ã€‚

**Dynamic, variable-width metadata**: With this approach, metadata assigned to causally-related activity can change in size in addition to value. Doing so would allow metadata to include interval-tree clocks [3]() instead of simple logical clocks. Like vector clocks, interval-tree clocks reduce brittleness since any two timestamps can be compared to determine if they are concurrent or if one happened before another. But, unlike vector clocks, interval-tree clocks can grow and shrink in proportion to the number of active threads. In contrast, variable-width vector clocks cannot shrink and so require width proportional to the maximum number of threads observed in a workflow. Vector clocks also require globally unique, well-known thread IDs [3](). Currently, no existing tracing infrastructure uses vector clocks or interval-tree clocks.
**åŠ¨æ€çš„ã€å¯å˜å®½åº¦çš„å…ƒæ•°æ®**ï¼šé€šè¿‡è¿™ç§æ–¹æ³•ï¼Œåˆ†é…ç»™å› æœå…³ç³»æ´»åŠ¨çš„å…ƒæ•°æ®é™¤äº†å€¼ï¼ˆvalueï¼‰ä¹‹å¤–è¿˜å¯ä»¥æ”¹å˜å¤§å°ã€‚è¿™æ ·åšå°†å…è®¸å…ƒæ•°æ®åŒ…æ‹¬**åŒºé—´æ ‘æ—¶é’Ÿ**[3]()è€Œä¸æ˜¯ç®€å•çš„é€»è¾‘æ—¶é’Ÿã€‚åƒçŸ¢é‡æ—¶é’Ÿä¸€æ ·ï¼ŒåŒºé—´æ ‘æ—¶é’Ÿå‡å°‘äº†è„†æ€§ï¼Œå› ä¸ºä»»ä½•ä¸¤ä¸ªæ—¶é—´æˆ³éƒ½å¯ä»¥è¢«æ¯”è¾ƒï¼Œä»¥ç¡®å®šå®ƒä»¬æ˜¯å¦åŒæ—¶å‘ç”Ÿï¼Œæˆ–è€…ä¸€ä¸ªå‘ç”Ÿåœ¨å¦ä¸€ä¸ªä¹‹å‰ã€‚ä½†æ˜¯ï¼Œä¸çŸ¢é‡æ—¶é’Ÿä¸åŒçš„æ˜¯ï¼ŒåŒºé—´æ ‘æ—¶é’Ÿå¯ä»¥æ ¹æ®æ´»åŠ¨çº¿ç¨‹çš„æ•°é‡æŒ‰æ¯”ä¾‹å¢é•¿å’Œæ”¶ç¼©ã€‚ç›¸åï¼Œå¯å˜å®½åº¦çš„çŸ¢é‡æ—¶é’Ÿä¸èƒ½æ”¶ç¼©ï¼Œå› æ­¤éœ€è¦ä¸å·¥ä½œæµä¸­è§‚å¯Ÿåˆ°çš„æœ€å¤§çº¿ç¨‹æ•°æˆæ¯”ä¾‹çš„å®½åº¦ã€‚çŸ¢é‡æ—¶é’Ÿè¿˜éœ€è¦å…¨çƒå”¯ä¸€çš„ã€ä¼—æ‰€å‘¨çŸ¥çš„çº¿ç¨‹ID[3]()ã€‚ç›®å‰ï¼Œæ²¡æœ‰ä»»ä½•ç°æœ‰çš„è¿½è¸ªåŸºç¡€è®¾æ–½ä½¿ç”¨çŸ¢é‡æ—¶é’Ÿæˆ–é—´éš”æ ‘æ—¶é’Ÿã€‚

> Tracing infrastructures that wish to make full traces (or other data that requires tying together causally- related activity) available immediately without explicit trace construction must use dynamic, variable-width metadata. For example, tracing infrastructures that use dynamic, variable-width metadata could carry executed trace-point records within metadata, making them immediately available for use as soon as the workflow ends. Whodunit [9]() is the only existing tracing implementation that carries trace-point records (i.e., function names) in metadata. To reduce metadata size, heuristics are used to reduce the number of propagated trace-point records, but trace fidelity is reduced as a result.
å¸Œæœ›åœ¨æ²¡æœ‰æ˜ç¡®çš„è·Ÿè¸ªæ„å»ºçš„æƒ…å†µä¸‹ç«‹å³æä¾›å®Œæ•´çš„è·Ÿè¸ªï¼ˆæˆ–å…¶ä»–éœ€è¦å°†å› æœå…³ç³»çš„æ´»åŠ¨è”ç³»èµ·æ¥çš„æ•°æ®ï¼‰çš„è·Ÿè¸ªåŸºç¡€è®¾æ–½å¿…é¡»ä½¿ç”¨åŠ¨æ€çš„ã€å¯å˜å®½åº¦çš„å…ƒæ•°æ®ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨åŠ¨æ€ã€å¯å˜å®½åº¦å…ƒæ•°æ®çš„è¿½è¸ªåŸºç¡€è®¾æ–½å¯ä»¥åœ¨å…ƒæ•°æ®ä¸­æºå¸¦å·²æ‰§è¡Œçš„è¿½è¸ªç‚¹è®°å½•ï¼Œä¸€æ—¦å·¥ä½œæµç¨‹ç»“æŸï¼Œå°±å¯ä»¥ç«‹å³ä½¿ç”¨è¿™äº›è®°å½•ã€‚Whodunit[9]()æ˜¯å”¯ä¸€ä¸€ä¸ªåœ¨å…ƒæ•°æ®ä¸­æºå¸¦è·Ÿè¸ªç‚¹è®°å½•ï¼ˆå³å‡½æ•°åç§°ï¼‰çš„ç°æœ‰è·Ÿè¸ªå®ç°ã€‚ä¸ºäº†å‡å°‘å…ƒæ•°æ®çš„å¤§å°ï¼Œ**å¯å‘å¼æ–¹æ³•**è¢«ç”¨æ¥å‡å°‘ä¼ æ’­çš„è¿½è¸ªç‚¹è®°å½•çš„æ•°é‡ï¼Œä½†è¿½è¸ªçš„ä¿çœŸåº¦ä¹Ÿå› æ­¤è€Œé™ä½ã€‚
## 4.2 How to preserve forks and joins
4.2 å¦‚ä½•ä¿å­˜forkå’Œjoin
> For the static and dynamic, fixed-width metadata-propagation approaches discussed above, forks and joins can be preserved via one-to-many and many-to-one trace points. For the static approach, such trace points must include clues that uniquely identify the activity being forked or waited onâ€”for example, thread IDs. For dynamic, fixed-width approaches, one-to-many trace points should include the current logical-clock value and the logical-clock values that will be initially used by each of the forked descendants. Join trace points should include the current logical-clock value and the logical-clock values of all events that must complete before work can proceed. Dynamic, variable-width approaches can infer forks and joins if they include interval-tree clocks.
å¯¹äºä¸Šé¢è®¨è®ºçš„é™æ€å’ŒåŠ¨æ€ã€å›ºå®šå®½åº¦çš„å…ƒæ•°æ®ä¼ æ’­æ–¹æ³•ï¼Œfork å’Œ join å¯ä»¥é€šè¿‡**ä¸€å¯¹å¤š**å’Œ**å¤šå¯¹ä¸€çš„è·Ÿè¸ªç‚¹**æ¥ä¿å­˜ã€‚å¯¹äº**é™æ€æ–¹æ³•ï¼Œè¿™ç§è·Ÿè¸ªç‚¹å¿…é¡»åŒ…æ‹¬å”¯ä¸€è¯†åˆ«è¢«fork æˆ–ç­‰å¾…çš„æ´»åŠ¨çš„çº¿ç´¢--ä¾‹å¦‚ï¼Œçº¿ç¨‹ID**ã€‚å¯¹äº**åŠ¨æ€çš„ã€å›ºå®šå®½åº¦çš„æ–¹æ³•ï¼Œä¸€å¯¹å¤š****çš„è·Ÿè¸ªç‚¹åº”è¯¥åŒ…æ‹¬å½“å‰çš„é€»è¾‘æ—¶é’Ÿå€¼å’Œæ¯ä¸ªfork çš„å­å­™æœ€åˆä½¿ç”¨çš„é€»è¾‘æ—¶é’Ÿå€¼**ã€‚è¿æ¥è·Ÿè¸ªç‚¹åº”è¯¥åŒ…æ‹¬å½“å‰çš„é€»è¾‘æ—¶é’Ÿå€¼å’Œæ‰€æœ‰åœ¨å·¥ä½œè¿›è¡Œä¹‹å‰å¿…é¡»å®Œæˆçš„äº‹ä»¶çš„é€»è¾‘æ—¶é’Ÿå€¼ã€‚åŠ¨æ€çš„ã€å¯å˜å®½åº¦çš„æ–¹æ³•å¯ä»¥æ¨æ–­å‡ºåˆ†å‰å’Œè¿æ¥ï¼Œå¦‚æœå®ƒä»¬åŒ…æ‹¬åŒºé—´æ ‘æ—¶é’Ÿçš„è¯ã€‚
> An alternate approach, used by Mann et al. [31](), involves comparing large volumes of traces to automati- cally determine fork and join points.

Mannç­‰äºº[31]()ä½¿ç”¨çš„å¦ä¸€ç§æ–¹æ³•æ˜¯é€šè¿‡æ¯”è¾ƒå¤§é‡çš„è·Ÿè¸ªæ¥è‡ªåŠ¨ç¡®å®š fork å’Œjoin çš„ç‚¹ã€‚

[17]:	https://en.wikipedia.org/wiki/Interval_tree


[image-1]:	https://tva1.sinaimg.cn/large/008i3skNly1gsvlo5c2hmj310809y75a.jpg