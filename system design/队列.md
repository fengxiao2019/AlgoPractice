队列


队列被用来有效管理大规模分布式系统中的请求。在处理负荷最小的小型系统和小型数据库中，写入的速度可以预测；然而，在更复杂的大型系统中，写入的时间比较长且无法确定。例如，数据可能要写在不同服务器或索引的不同地方，或者系统可能只是处于高负荷状态。在这种情况下，单个写入（或任务）可能需要很长的时间，要实现高性能和可用性，需要系统的不同组件以异步的方式工作；一个常见的方式是使用队列。

让我们假设一个系统，每个客户都在请求在远程服务器上处理一个任务。每个客户都向服务器发送请求，而服务器则试图尽快完成任务，将结果返回给各自的客户。在小型系统中，一台服务器可以以最快的速度处理传入的请求，这种情况应该可以正常工作。然而，当服务器收到的请求超过它所能处理的数量时，那么每个客户就不得不等待其他客户的请求完成后才能产生响应。
这种同步行为会严重降低客户端的性能；客户端被迫等待，实际上是在做零工，直到其请求被响应。增加额外的服务器来解决高负载问题也不能解决问题；即使有有效的负载平衡，也很难确保公平和平衡的工作分配，以最大限度地提高客户端的性能。此外，如果处理请求的服务器不可用，或发生故障，那么上游的客户也会失败。要有效地解决这个问题，需要在客户的请求和为其提供服务的实际工作之间建立一个抽象概念。
![][image-1]

所有进入的任务都被添加到队列中，只要任何消费者有能力处理，他们就可以从队列中拿起一个任务。这些任务可以是向数据库的简单写入，也可以是为文档生成缩略图预览图这样复杂的任务。
队列是在**异步通信协议**上实现的，这意味着当客户端向队列提交任务时，他们不再需要等待结果；相反，他们只需要确认请求被正确接收。这种确认后来可以作为客户需要时工作结果的参考。队列对单个请求中可能传输的数据大小以及队列中可能保持未处理的请求数量有隐含或明确的限制。
队列也被**用于容错**，因为它们可以提供一些保护，防止服务中断和失败。例如，我们可以创建一个高度稳健的队列，可以重试由于瞬时系统故障而失败的服务请求。使用队列来执行服务质量保证，比让客户直接暴露在间歇性的服务中断中要好得多，因为这需要复杂且经常不一致的客户方错误处理。
队列在管理任何大规模分布式系统的不同部分之间的分布式通信方面发挥着重要作用。有很多方法可以实现它们，也有不少队列的开源实现，如RabbitMQ、ZeroMQ、ActiveMQ和BeanstalkD。

## 队列设计
设计消息队列的整体思路是先build一个整体的数据流，例如producer发送给broker，broker发送给consumer，consumer回复消费确认，broker删除/备份消息等。 
利用RPC将数据流串起来，然后考虑RPC的高可用性，尽量做到无状态，方便水平扩展。
考虑如何承载消息堆积，然后在合适的时机投递消息，而处理堆积的最佳方式，就是存储，存储的选型需要综合考虑性能/可靠性和开发维护成本等诸多因素。 
为了实现广播功能，我们必须要维护消费关系，可以利用zk/config server等保存消费关系。 在完成了上述几个功能后，消息队列基本就实现了。然后我们可以考虑一些高级特性，如可靠投递，事务特性，性能优化等。

### 使用场景
#### 解耦
解耦是消息队列要解决的最本质问题。所谓解耦，简单点讲就是一个事务，只关心核心的流程。而需要依赖其他系统但不那么重要的事情，有通知即可，无需等待结果。换句话说，基于消息的模型，关心的是“通知”，而非“处理”。
#### 最终一致性
最终一致性指的是两个系统的状态保持一致，要么都成功，要么都失败。当然有个时间限制，理论上越快越好，但实际上在各种异常的情况下，可能会有一定延迟达到最终一致状态，但最后两个系统的状态是一样的。
主要采取的方案： “记录” + “补偿”。
#### 广播
消息队列的基本功能之一是进行广播。如果没有消息队列，每当一个新的业务方接入，我们都要联调一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。 比如本文开始提到的产品中心发布产品变更的消息，以及景点库很多去重更新的消息，可能“关心”方有很多个，但产品中心和景点库只需要发布变更消息即可，谁关心谁接入。



[image-1]:	https://tva1.sinaimg.cn/large/008i3skNly1gr50wrfyhij30vo0kmq8p.jpg