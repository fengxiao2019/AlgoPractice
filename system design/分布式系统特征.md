# 分布式系统特征
协调算法
读读 - 没问题
读写 -  脏读 幻读
写写 - 脏写   写覆盖 写倾斜问题

ACID AID 最终目标都是C
理念：如果存在违反原子性、隔离性或持久性的风险，那么完全放弃整个事务，注意是完全放弃。
原子性 - 在出错时中止事务，并将部分完成的写入全部丢弃。
一致性 - 事务从一个有效的状态转移到另一个有效的状态。
隔离性 - 并发执行的多个事务相互隔离，不能交叉。
持久性 - 事务提交之后，数据已经被写入非易失性存储设备。

## 隔离级别
### 读-提交
1. 读数据库时，只能看到已经成功提交的数据（防止“脏读”）。
2. 写数据库时，只会覆盖已成功提交的数据（防止“脏写”）。

为什么要解决脏读和脏写问题？
脏读和脏写问题会导致数据紊乱。

#### 脏读
定义- B事务读到了A事务未提交的数据
避免的手段
对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本，在事务提交之前，所有其他读操作都读取旧值；仅当写事务提交之后，才会切换到读取新值。
支持快照级别隔离的存储引擎往往采用MVCC来实现读-提交隔离，对每一个不同的查询单度创建一个快照。
#### 脏写
A事务和B事务同时尝试更新相同的对象，如果A事务写入了值，尚未提交，被B事务覆盖了，这就是脏写。
避免的手段
行级锁- 当事务想修改某个对象时，先持有锁，直到事务提交之后才释放锁。
### 可重复读
关键点 - 读操作和写操作相互隔离。
实现方式
MVCC。
索引的修改
当需要更新时，不会修改现有的页面，而总是创建一个新的修改副本，拷贝必要的内容，然后让父节点，或者递归向上直到树的root节点指向新创建的节点，那些不受更新影响的页面都不需要复制，保持不变并被父节点所指向。
#### 如何防止更新丢失？
原子写操作
显式加锁
select xxx from table for update.
原子比较和设置（Check and Set）
冲突解决与复制（多个最新的数据副本，例如共享文档的编辑）
#### 幻读（读倾斜）和 写倾斜
gap-lock
#### 两阶段锁
2PL






